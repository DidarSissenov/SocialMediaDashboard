{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useClockEvents;\nvar _react = require(\"react\");\nvar _constants = require(\"../helpers/constants\");\nvar _dom = require(\"../helpers/dom\");\nvar _math = require(\"../helpers/math\");\nconst {\n  atan2\n} = Math;\n\n/*\n\tsolely responsible for transforming click events into\n\tangles (which are later converted into time depending\n\ton current mode and other restrictions)\n*/\nfunction useClockEvents(clock, handleChange) {\n  const wrapper = (0, _react.useRef)(null);\n  const calcOffsetCache = (0, _react.useRef)(null);\n  const dragCount = (0, _react.useRef)(0);\n  const cleanupRef = (0, _react.useRef)(() => {}); // avoid recomputing all the event listeners, prolly unnecessary...\n\n  const handleChangeRef = (0, _react.useRef)(handleChange);\n  (0, _react.useEffect)(() => {\n    handleChangeRef.current = handleChange;\n  }, [handleChange]);\n  const calculatePoint = (0, _react.useCallback)((offsetX, offsetY, canAutoChangeMode) => {\n    // if user just clicks/taps a number (drag count < 2), then just assume it's a rough tap\n    // and force a rounded/coarse number (ie: 1, 2, 3, 4 is tapped, assume 0 or 5)\n    const wasTapped = dragCount.current < 2;\n    const x = offsetX - _constants.CLOCK_RADIUS;\n    const y = -offsetY + _constants.CLOCK_RADIUS;\n    const a = atan2(y, x);\n    let d = 90 - (0, _math.deg)(a);\n    if (d < 0) {\n      d = 360 + d;\n    } // ensure touch doesn't bleed outside of clock radius\n\n    if (!(0, _math.isWithinRadius)(x, y, _constants.CLOCK_RADIUS) && wasTapped) {\n      return false;\n    }\n    const isInnerClick = (0, _math.isWithinRadius)(x, y, _constants.INNER_NUMBER_RADIUS); // update time on main\n\n    handleChangeRef.current(d, {\n      canAutoChangeMode,\n      wasTapped,\n      isInnerClick\n    });\n  }, []); // handle mouse + touch changes\n\n  const handleMouseUp = (0, _react.useCallback)(e => {\n    if (!clock.current) {\n      return;\n    }\n    clock.current.style.cursor = '';\n    const {\n      offsetX,\n      offsetY\n    } = calcOffsetCache.current(e.clientX, e.clientY);\n    calculatePoint(offsetX, offsetY, true);\n  }, [calculatePoint, clock]);\n  const handleTouchEnd = (0, _react.useCallback)(e => {\n    const touch = e.targetTouches[0] || e.changedTouches[0];\n    if (touch && calcOffsetCache.current) {\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(touch.clientX, touch.clientY);\n      calculatePoint(offsetX, offsetY, true);\n    }\n  }, [calculatePoint]);\n  const handleMouseDrag = (0, _react.useCallback)(e => {\n    if (calcOffsetCache.current) {\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(e.clientX, e.clientY);\n      calculatePoint(offsetX, offsetY, false);\n    }\n    dragCount.current++;\n    if (dragCount.current === 1 && clock.current) {\n      clock.current.style.cursor = '-webkit-grabbing';\n      clock.current.style.cursor = 'grabbing';\n    }\n    e.preventDefault();\n    return false;\n  }, [calculatePoint, clock]);\n  const handleTouchDrag = (0, _react.useCallback)(e => {\n    if (calcOffsetCache.current) {\n      const touch = e.targetTouches[0];\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(touch.clientX, touch.clientY);\n      calculatePoint(offsetX, offsetY, false);\n    }\n    dragCount.current++;\n    e.preventDefault();\n    return false;\n  }, [calculatePoint]); // stop mouse + touch events\n\n  const handleStopDrag = (0, _react.useCallback)(e => {\n    cleanupRef.current();\n    if (e == null || clock.current == null) {\n      return;\n    }\n    if (isMouseEventEnd(e)) {\n      handleMouseUp(e);\n    } else if (isTouchEventEnd(e)) {\n      handleTouchEnd(e);\n    }\n    function isMouseEventEnd(e) {\n      return e.type === 'mouseup';\n    }\n    function isTouchEventEnd(e) {\n      return e.type === 'touchcancel' || e.type === 'touchend';\n    }\n  }, [handleMouseUp, handleTouchEnd, clock]); // mouse events\n\n  const handleMouseDown = (0, _react.useCallback)(e => {\n    dragCount.current = 0; // terminate if click is outside of clock radius, ie:\n    // if clicking meridiem button which overlaps with clock\n\n    if (clock.current) {\n      calcOffsetCache.current = (0, _dom.calcOffset)(clock.current);\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(e.clientX, e.clientY);\n      const x = offsetX - _constants.CLOCK_RADIUS;\n      const y = offsetY - _constants.CLOCK_RADIUS;\n      if (!(0, _math.isWithinRadius)(x, y, _constants.CLOCK_RADIUS)) return;\n    } // add listeners\n\n    document.addEventListener('mousemove', handleMouseDrag, false);\n    document.addEventListener('mouseup', handleStopDrag, false);\n    wrapper.current && wrapper.current.addEventListener('mouseleave', handleStopDrag, false); // @ts-ignore\n\n    handleMouseDrag(e);\n  }, [clock, handleMouseDrag, handleStopDrag]); // touch events\n\n  const handleTouchStart = (0, _react.useCallback)(e => {\n    e.preventDefault();\n    dragCount.current = 0; // add listeners\n\n    document.addEventListener('touchmove', handleTouchDrag, false);\n    document.addEventListener('touchend', handleStopDrag, false);\n    document.addEventListener('touchcancel', handleStopDrag, false);\n    if (clock.current) {\n      calcOffsetCache.current = (0, _dom.calcOffset)(clock.current);\n    }\n  }, [clock, handleStopDrag, handleTouchDrag]); // attach touchstart event manually to the clock to make it cancelable.\n\n  (0, _react.useEffect)(() => {\n    const currentTarget = clock.current;\n    const type = 'touchstart';\n    if (currentTarget) {\n      currentTarget.addEventListener(type, handleTouchStart, false);\n    }\n    return () => {\n      if (currentTarget) {\n        currentTarget.removeEventListener(type, handleTouchStart, false);\n      }\n    };\n  }, [clock, handleTouchStart]);\n  /*\n  \tdeals with circular dependencies of callback functions; add listener function\n  \tdepends on remove listener function and vice versa\n  \ton remove listener function which depends on the add listener cb\n  */\n\n  (0, _react.useEffect)(() => {\n    cleanupRef.current = () => {\n      document.removeEventListener('mousemove', handleMouseDrag, false);\n      document.removeEventListener('mouseup', handleStopDrag, false);\n      wrapper.current && wrapper.current.removeEventListener('mouseleave', handleStopDrag, false);\n      document.removeEventListener('touchmove', handleTouchDrag, false);\n      document.removeEventListener('touchend', handleStopDrag, false);\n      document.removeEventListener('touchcancel', handleStopDrag, false);\n    };\n  }, [handleMouseDrag, handleStopDrag, handleTouchDrag]); // clean up\n\n  (0, _react.useEffect)(() => {\n    return cleanupRef.current;\n  }, []);\n  return {\n    bind: {\n      onMouseDown: handleMouseDown,\n      ref: wrapper\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","useClockEvents","_react","require","_constants","_dom","_math","atan2","Math","clock","handleChange","wrapper","useRef","calcOffsetCache","dragCount","cleanupRef","handleChangeRef","useEffect","current","calculatePoint","useCallback","offsetX","offsetY","canAutoChangeMode","wasTapped","x","CLOCK_RADIUS","y","a","d","deg","isWithinRadius","isInnerClick","INNER_NUMBER_RADIUS","handleMouseUp","e","style","cursor","clientX","clientY","handleTouchEnd","touch","targetTouches","changedTouches","handleMouseDrag","preventDefault","handleTouchDrag","handleStopDrag","isMouseEventEnd","isTouchEventEnd","type","handleMouseDown","calcOffset","document","addEventListener","handleTouchStart","currentTarget","removeEventListener","bind","onMouseDown","ref"],"sources":["C:/Users/groop/social_media_dashboard/frontend/node_modules/react-timekeeper/lib/hooks/useClockEvents.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useClockEvents;\n\nvar _react = require(\"react\");\n\nvar _constants = require(\"../helpers/constants\");\n\nvar _dom = require(\"../helpers/dom\");\n\nvar _math = require(\"../helpers/math\");\n\nconst {\n  atan2\n} = Math;\n\n/*\n\tsolely responsible for transforming click events into\n\tangles (which are later converted into time depending\n\ton current mode and other restrictions)\n*/\nfunction useClockEvents(clock, handleChange) {\n  const wrapper = (0, _react.useRef)(null);\n  const calcOffsetCache = (0, _react.useRef)(null);\n  const dragCount = (0, _react.useRef)(0);\n  const cleanupRef = (0, _react.useRef)(() => {}); // avoid recomputing all the event listeners, prolly unnecessary...\n\n  const handleChangeRef = (0, _react.useRef)(handleChange);\n  (0, _react.useEffect)(() => {\n    handleChangeRef.current = handleChange;\n  }, [handleChange]);\n  const calculatePoint = (0, _react.useCallback)((offsetX, offsetY, canAutoChangeMode) => {\n    // if user just clicks/taps a number (drag count < 2), then just assume it's a rough tap\n    // and force a rounded/coarse number (ie: 1, 2, 3, 4 is tapped, assume 0 or 5)\n    const wasTapped = dragCount.current < 2;\n    const x = offsetX - _constants.CLOCK_RADIUS;\n    const y = -offsetY + _constants.CLOCK_RADIUS;\n    const a = atan2(y, x);\n    let d = 90 - (0, _math.deg)(a);\n\n    if (d < 0) {\n      d = 360 + d;\n    } // ensure touch doesn't bleed outside of clock radius\n\n\n    if (!(0, _math.isWithinRadius)(x, y, _constants.CLOCK_RADIUS) && wasTapped) {\n      return false;\n    }\n\n    const isInnerClick = (0, _math.isWithinRadius)(x, y, _constants.INNER_NUMBER_RADIUS); // update time on main\n\n    handleChangeRef.current(d, {\n      canAutoChangeMode,\n      wasTapped,\n      isInnerClick\n    });\n  }, []); // handle mouse + touch changes\n\n  const handleMouseUp = (0, _react.useCallback)(e => {\n    if (!clock.current) {\n      return;\n    }\n\n    clock.current.style.cursor = '';\n    const {\n      offsetX,\n      offsetY\n    } = calcOffsetCache.current(e.clientX, e.clientY);\n    calculatePoint(offsetX, offsetY, true);\n  }, [calculatePoint, clock]);\n  const handleTouchEnd = (0, _react.useCallback)(e => {\n    const touch = e.targetTouches[0] || e.changedTouches[0];\n\n    if (touch && calcOffsetCache.current) {\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(touch.clientX, touch.clientY);\n      calculatePoint(offsetX, offsetY, true);\n    }\n  }, [calculatePoint]);\n  const handleMouseDrag = (0, _react.useCallback)(e => {\n    if (calcOffsetCache.current) {\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(e.clientX, e.clientY);\n      calculatePoint(offsetX, offsetY, false);\n    }\n\n    dragCount.current++;\n\n    if (dragCount.current === 1 && clock.current) {\n      clock.current.style.cursor = '-webkit-grabbing';\n      clock.current.style.cursor = 'grabbing';\n    }\n\n    e.preventDefault();\n    return false;\n  }, [calculatePoint, clock]);\n  const handleTouchDrag = (0, _react.useCallback)(e => {\n    if (calcOffsetCache.current) {\n      const touch = e.targetTouches[0];\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(touch.clientX, touch.clientY);\n      calculatePoint(offsetX, offsetY, false);\n    }\n\n    dragCount.current++;\n    e.preventDefault();\n    return false;\n  }, [calculatePoint]); // stop mouse + touch events\n\n  const handleStopDrag = (0, _react.useCallback)(e => {\n    cleanupRef.current();\n\n    if (e == null || clock.current == null) {\n      return;\n    }\n\n    if (isMouseEventEnd(e)) {\n      handleMouseUp(e);\n    } else if (isTouchEventEnd(e)) {\n      handleTouchEnd(e);\n    }\n\n    function isMouseEventEnd(e) {\n      return e.type === 'mouseup';\n    }\n\n    function isTouchEventEnd(e) {\n      return e.type === 'touchcancel' || e.type === 'touchend';\n    }\n  }, [handleMouseUp, handleTouchEnd, clock]); // mouse events\n\n  const handleMouseDown = (0, _react.useCallback)(e => {\n    dragCount.current = 0; // terminate if click is outside of clock radius, ie:\n    // if clicking meridiem button which overlaps with clock\n\n    if (clock.current) {\n      calcOffsetCache.current = (0, _dom.calcOffset)(clock.current);\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(e.clientX, e.clientY);\n      const x = offsetX - _constants.CLOCK_RADIUS;\n      const y = offsetY - _constants.CLOCK_RADIUS;\n      if (!(0, _math.isWithinRadius)(x, y, _constants.CLOCK_RADIUS)) return;\n    } // add listeners\n\n\n    document.addEventListener('mousemove', handleMouseDrag, false);\n    document.addEventListener('mouseup', handleStopDrag, false);\n    wrapper.current && wrapper.current.addEventListener('mouseleave', handleStopDrag, false); // @ts-ignore\n\n    handleMouseDrag(e);\n  }, [clock, handleMouseDrag, handleStopDrag]); // touch events\n\n  const handleTouchStart = (0, _react.useCallback)(e => {\n    e.preventDefault();\n    dragCount.current = 0; // add listeners\n\n    document.addEventListener('touchmove', handleTouchDrag, false);\n    document.addEventListener('touchend', handleStopDrag, false);\n    document.addEventListener('touchcancel', handleStopDrag, false);\n\n    if (clock.current) {\n      calcOffsetCache.current = (0, _dom.calcOffset)(clock.current);\n    }\n  }, [clock, handleStopDrag, handleTouchDrag]); // attach touchstart event manually to the clock to make it cancelable.\n\n  (0, _react.useEffect)(() => {\n    const currentTarget = clock.current;\n    const type = 'touchstart';\n\n    if (currentTarget) {\n      currentTarget.addEventListener(type, handleTouchStart, false);\n    }\n\n    return () => {\n      if (currentTarget) {\n        currentTarget.removeEventListener(type, handleTouchStart, false);\n      }\n    };\n  }, [clock, handleTouchStart]);\n  /*\n  \tdeals with circular dependencies of callback functions; add listener function\n  \tdepends on remove listener function and vice versa\n  \ton remove listener function which depends on the add listener cb\n  */\n\n  (0, _react.useEffect)(() => {\n    cleanupRef.current = () => {\n      document.removeEventListener('mousemove', handleMouseDrag, false);\n      document.removeEventListener('mouseup', handleStopDrag, false);\n      wrapper.current && wrapper.current.removeEventListener('mouseleave', handleStopDrag, false);\n      document.removeEventListener('touchmove', handleTouchDrag, false);\n      document.removeEventListener('touchend', handleStopDrag, false);\n      document.removeEventListener('touchcancel', handleStopDrag, false);\n    };\n  }, [handleMouseDrag, handleStopDrag, handleTouchDrag]); // clean up\n\n  (0, _react.useEffect)(() => {\n    return cleanupRef.current;\n  }, []);\n  return {\n    bind: {\n      onMouseDown: handleMouseDown,\n      ref: wrapper\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}